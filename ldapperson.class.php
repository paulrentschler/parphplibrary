<?php
  /**
   * Provides a way of querying the PSU LDAP server for a user record
   *   and parsing the LDAP user information into meaningful data.
   * 
   * Refactored the code on 6 September 2011 to make this a PHP5 class
   *   and make it easier to debug problems with the lookup and parsing.
   * 
   * @author Paul Rentschler <par117@psu.edu>
   * @since 15 June 2009
   */
  class LDAPPerson {

    /**
     * Stores the parsed and sanitized user information.
     */
    protected $person = array();
    
    /**
     * Stores the raw data returned from the LDAP server for debugging purposes.
     */
    protected $rawData;
    
    /**
     * Store a list of error messages.
     */
    protected $errors = array();
    


    /**
     * Instance constructor that sets the fields that we will be
     *   parsing from the LDAP data and presenting as a "person".
     * 
     * @author Paul Rentschler <par117@psu.edu>
     * @since 15 June 2009
     */
    function __construct() {
      
      // setup the default properies for a person
      $this->person = array( 'firstname' => '',
                             'middlename' => '',
                             'lastname' => '',
                             'emailaddress' => '',
                             'preferredemailaddress' => '',
                             'homedirectory' => '',
                             'primaryaffiliation' => '',
                             'adminarea' => '',
                             'department' => '',
                             'jobtitle' => '',
                             'officeaddress' => '',
                             'officephone' => '',
                             'website' => '',
                             'groups' => array(),
                           );
      
    }  // end of function __construct


    
    /**
     * Clear the list of errors.
     * 
     * @author Paul Rentschler <par117@psu.edu>
     * @since 6 September 2011
     */
    public function clearErrors () {
      
      $this->errors = array();
      
    }  // end of function clearErrors
    
    
    
    /**
     * Get the list of error messages generated.
     * 
     * @return array The array of error messages generated by the class methods.
     * @author Paul Rentschler <par117@psu.edu>
     * @since 6 September 2011
     */
    public function getErrors () {
      
      return $this->errors;
      
    }  // end of function getErrors
    
    
    
    /**
     * Get the entire person record as an associative array.
     * 
     * @return array An associative array of values representing a person.
     * @author Paul Rentschler <par117@psu.edu>
     * @since 6 September 2011
     */
    public function getPerson () {
      
      return $this->person;
      
    }  // end of function getPerson
    
    
    
    /**
     * Get the raw data array that was returned from the PSU LDAP server.
     * This is meant for debugging purposes and not for the faint of heart.
     * 
     * @return array The array of raw data returned from the PSU LDAP server.
     * @author Paul Rentschler <par117@psu.edu>
     * @since 6 September 2011
     */
    public function getRawData () {

      return $this->rawData;
      
    }  // end of function getRawData
    
    
    
    /**
     * Look up the specified Access Account in the PSU LDAP server.
     * 
     * @param accessAccountId string The PSU Access Account to lookup.
     * @return boolean Whether or not the lookup was successful.
     * @author Paul Rentschler <par117@psu.edu>
     * @since 15 June 2009
     */
    public function lookup ($accessAccountId) {
      
      $result = false;
      
      // make sure accessAccountId is provided and is alpha-numeric
      if (isset($accessAccountId) && $accessAccountId <> '' && ctype_alnum($accessAccountId)) {
        // open a connection to the server
        $ds = ldap_connect('dirapps.aset.psu.edu');
        if ($ds) {
          // bind to the directory
          $request = ldap_bind($ds);
     
          // search for the user record
          $result = ldap_search($ds, 'dc=psu,dc=edu', 'uid='.$accessAccountId);
     
          // get the user record(s)
          $this->rawData = ldap_get_entries($ds, $result);
          
          // there could be more than one hit in the LDAP database,
          //   if there is, throw an error.
          //   otherwise, take the first entry.
          if (isset($this->rawData['count']) && $this->rawData['count'] > 1) {
            $this->errors[] = 'More than one record was returned for this access account.';
            
          } else {
            $result = $this->_parseRecord();
          }
        }
     
        ldap_close($ds);
      }
      
      return $result;
      
    }  // end of function lookup
    
    
    
    /**
     * Provides a generic get method for accessing the fields of
     *   the person array.
     *   
     * The property name must be prefixed with the word "get".
     * 
     * @param string $method The undefined method being called.
     * @param array $arguments An array of arguments passed to the undefined method.
     * @return string Returns the value of the $this->person array entry that was prefixed with "get".
     * @example $this->getFirstName() returns $this->person['firstname']
     * @author Paul Rentschler <par117@psu.edu>
     * @since 6 September 2011
     */
    public function __call ($method, $arguments) {
      
      // break the method into the prefix and field name (property)
      $prefix = strtolower(substr($method, 0, 3));
      $property = strtolower(substr($method, 3));
      
      // assume the worst
      $result = '';
      
      // see if the field exists and return it
      if ($prefix == 'get' && isset($this->person[$property])) {
        $result = $this->person[$property];
      }
      
      return $result;
      
    }  // end of function __get
    
    
    
    /**
     * Parse the current LDAP record into the $this->person array
     *   and sanitize the data along the way.
     *   
     * @return boolean Whether or not the parsing was successful.
     * @author Paul Rentschler <par117@psu.edu>
     * @since 6 September 2011
     */
    protected function _parseRecord () {
      
      // assume the worst
      $result = false;
      
      
      // make sure we have raw data
      if (isset($this->rawData['count']) && $this->rawData['count'] == 1) {
        $details = $this->rawData[0];
      
        // parse for the firstname and middlename
        $givenName = trim(ucwords(strtolower($details['givenname'][0])));
        if (strpos($givenName, ' ') !== false) {
          list($this->person['firstname'], $this->person['middlename']) = explode(' ', $givenName, 2);
        } else {
          $this->person['firstname'] = $givenName;
          $this->person['middlename'] = '';
        }
        $this->person['firstname'] = trim($this->person['firstname']);
        $this->person['middlename'] = trim($this->person['middlename']);
        
        // parse the lastname
        $this->person['lastname'] = trim(ucwords(strtolower($details['sn'][0])));
        
        // build a hash to cross-reference between the LDAP field and the person record field
        //   format: person record field => LDAP field
        $xRef = array( 'emailaddress' => 'mail',
                       'preferredemailaddress' => 'psmailbox',
                       'homedirectory' => 'homedirectory',
                       'primaryaffiliation' => 'edupersonprimaryaffiliation',
                       'adminarea' => 'psadminarea',
                       'department' => 'psdepartment',
                       'jobtitle' => 'title',
                       'officeaddress' => 'psofficeaddress',
                       'officephone' => 'psofficephone',
                       'website' => 'labeleduri',
                     );
                     
        // use the cross-reference hash to parse for the remaining person information
        foreach ($xRef as $personField => $ldapField) {
          if (isset($details[$ldapField]) && count($details[$ldapField]) > 0) {
            $this->person[$personField] = trim($details[$ldapField][0]);
          }
        }
        $this->person['officeaddress'] = str_replace('$', "\n", $this->person['officeaddress']);
        
        // clean up incomplete phone numbers
        $pattern = '/[0-9]{3}-[0-9]{4}/';
        if (preg_match($pattern, $this->person['officephone'])) {
          $this->person['officephone'] = '814-'.$this->person['officephone'];
        }
        
        // build a list of groups this user belongs to
        if (isset($details['psmemberof']) && count($details['psmemberof']) > 0) {
          foreach ($details['psmemberof'] as $group) {
            if (strpos($group, '=') !== false) {
              list($id, $groupName) = explode('=', $group, 2);
              if ($groupName <> '') {
                $this->person['groups'][] = str_replace(',dc=psu,dc=edu', '', $groupName);
              }
            }
          }
        }
        
        $result = true;
      }
      
      return $result;
      
    }  // end of function _parseRecord
    
  }  // end of class LDAPPerson
