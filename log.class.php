<?php
  /**
   * Define the log message types.
   * 
   * @author Paul Rentschler <par117@psu.edu>
   */
  define('LOG_TYPE_APPLICATION', 'app');
  define('LOG_TYPE_DEBUG', 'debug');
  define('LOG_TYPE_ERROR', 'error');

  
  /**
   * Set the error handler.
   */
  set_error_handler(array('Log', 'handleError'));
  
  
  /**
   * Singleton object for logging messages to a file.
   * 
   * This object collects all messages generated by the
   *   the code that need to be written to a log file.
   *   
   * The following constants should be defined:
   *   DEBUGGING                 (true/false)
   *   CAN_CALL_DEVELOPER        (true/false)
   *   FILE_SUPPORT_TICKET       (true/false)
   *   SUPPORT_TICKET_URL        URL for submitting tickets
   *   NOTIFY_ON_ERROR           (true/false)
   *   NOTIFY_ERROR_ADDRESS      E-mail address to send error notifications TO
   *   NOTIFY_SENDER_ADDRESS     E-mail address to send error notifications FROM
   *   LOG_ERRORS                (true/false)
   *   LOG_ERRORS_FILE           Full path and filename to log errors to
   *   LOG_APPLICATION_FILE      Full path and filename to log application messages to
   *   
   * filename: /includes/log.class.php
   * 
   * @author Paul Rentschler <par117@psu.edu>
   * @since 25 February 2011
   */
  class Log {
    
    /**
     * Prevent anyone from creating an instance of this.
     */
    private function __construct() {} 
    
    /**
     * Prevent anyone from creating an instance of this.
     */
    private function __clone() {} 
    
    

    /**
     * Write a debug message to the debug log file
     * 
     * Adds a date/time stamp, filename, line number, and the current user to
     * the message provided and writes it out the debug log file specified
     * by LOG_DEBUG_FILE.
     * 
     * @param  string $message     a string containing the debug message
     * @param  string $filename    a string containing the filename where the
     *                             debug message was generated.  Use the 
     *                             special variable __FILE__ to provide this.
     * @param  string $lineNumber  a string containing the line number where
     *                             the debug message was generated. Use the
     *                             special variable __LINE__ to provide this.
     * @return void
     * @access public
     * @static
     * @author Paul Rentschler <par117@psu.edu>
     * @since  23 November 2011
     */
    public static function debug ($message, $filename = '', $lineNumber = '')
    {
        // are we in debug mode?
        if (defined('DEBUGGING') && DEBUGGING) {
            // make sure the message is not blank
            $message = trim($message);
            if ($message <> '') {
                // generate a date/time stamp
                $timestamp = date('Y-m-d H:i');
                
                // get the user
                $user = self::_getCurrentUser();
                
                // build the full log entry
                $logEntry = $timestamp.' -- ';
                if (trim($filename) <> '') {
                    $logEntry .= trim($filename);
                    if (trim($lineNumber) <> '') {
                        $logEntry .= ':'.trim($lineNumber);
                    }
                    $logEntry .= ' ';
                }
                if ($user <> '') {
                    $logEntry .= '('.$user.') ';
                }
                $logEntry .= '-- '.$message;
                
                // write the log entry
                self::_writeToFile(LOG_TYPE_DEBUG, $logEntry);
            }
        }
    }
    
    
    
    /**
     * Handle an error raised by the code.
     * 
     * It generates an error message with all the necessary information for
     *   debugging purposes and then outputs it to a log file.
     * 
     * @param integer $errNo The level of error raised.
     * @param string $errMsg The error message.
     * @param string $errFile The filename where the error occured (optional).
     * @param integer $errLine The line number where the error occured (optional).
     * @author Paul Rentschler <paul@rentschler.ws>
     */
    public static function handleError ($errNo, $errMsg, $errFile = '', $errLine = '') {
      
      // get a (hopefully) unique id for this error message
      $errorId = self::_generateErrorId();
            
      // build the error message
      $message = self::_buildErrorHeader($errorId);
      $message .= 'LOCATION: '.$errFile.', line '. $errLine."\n\n";
      $message .= 'TYPE: '.self::_convertErrorLevelToString($errNo)."\n";
      $message .= 'TEXT: '.$errMsg."\n";
      $message .= 'BACKTRACE:'."\n";
      $message .= self::_getBacktrace();
      
      // write the error message to the log
      if (defined('LOG_ERRORS') && LOG_ERRORS) {
        self::_writeToFile(LOG_TYPE_ERROR, $message);
      }
      
      // notify someone about the error
      if (defined('NOTIFY_ON_ERROR') && NOTIFY_ON_ERROR) {
        self::_sendErrorAlert($errorId, $errFile, $errLine);
      }
      
      // display the error message
      if (defined('DEBUGGING') && DEBUGGING) {
        // we are debugging so display the whole error message
        echo '<pre>'.htmlentities($message).'</pre>';
      }
        
      // determine if we should halt execution
      $haltExecution = false;
      if ($errNo == E_WARNING || $errNo == E_USER_WARNING) {
          // halt for warnings when we are debugging
          if (defined('DEBUGGING') && DEBUGGING) {
              $haltExecution = true;
          }
      } elseif ($errNo <> E_NOTICE && $errNo <> E_USER_NOTICE && $errNo <> E_STRICT) {
        // if it's not a notice, we are going to halt execution
        $haltExecution = true;
      }
      
      // display a user error and halt execution if needed
      if ($haltExecution) {
        // show a NICE error message to the user if we are not debugging
        if (!(defined('DEBUGGING') && DEBUGGING)) {
          echo '<h2>An error has occured in the '.APPLICATION_NAME.' application!</h2>';
          echo '<p>We are sorry but a serious error has occured which has caused the application to stop working.</p>';
          
          // let the user know what actions were taken regarding the error
          if (defined('NOTIFY_ON_ERROR') && NOTIFY_ON_ERROR && defined('LOG_ERRORS') && LOG_ERRORS) {
            echo '<p>';
            echo 'The developer has been notified and the error was saved ';
            echo 'for later review as error number: <strong>'.$errorId.'</strong>';
            echo '</p>';
          } elseif (defined('NOTIFY_ON_ERROR') && NOTIFY_ON_ERROR) {
            echo '<p>';
            echo 'The developer has been notified of the error.';
            echo '</p>';
          } elseif (defined('LOG_ERRORS') && LOG_ERRORS) {
            echo '<p>';
            echo 'The error was saved for later review as error number: <strong>'.$errorId.'</strong>';
            echo '</p>';
          }
          
          // encourage the user to file a support ticket
          if ( defined('FILE_SUPPORT_TICKET') && FILE_SUPPORT_TICKET <> '' &&
               defined('SUPPORT_TICKET_URL') && SUPPORT_TICKET_URL <> '' ) {
            echo '<p>';
            echo 'You can <a href="'.SUPPORT_TICKET_URL.'">file a support ticket</a> ';
            echo 'regarding this problem and provide us with more information about ';
            echo 'what you were doing when the error happened.';
            echo '</p>';
            echo '<p><strong>Please include the error number: '.$errorId.' in your ticket.</strong></p>';
          }
          
          // let the user know that a developer can rush to their aid if what they were doing was critical
          if (defined('CAN_CALL_DEVELOPER') && CAN_CALL_DEVELOPER) {
            echo '<p>';
            echo 'If you were doing something critical, please leave the ';
            echo 'browser <strong>just like it is</strong> and <strong>call</strong> ';
            echo 'the developer. <strong>DO NOT CLOSE THE BROWSER, HIT THE BACK, ';
            echo 'or REFRESH / RELOAD BUTTONS!</strong>';
            echo '</p>';
            echo '<p>';
            echo 'The developer will attempt to save what you were doing, but ';
            echo '<strong>it may already have been lost</strong>.';
            echo '</p>';
          }
        }
  
        // stop processing the request
        exit;         
      }
      
    }  // end of function handleError
    
    
    
    /**
     * Handle a SQL error caught by the code.
     * 
     * It generates an error message with all the necessary information for
     *   debugging purposes and then outputs it to a log file.
     * 
     * @param string $errMsg The error message as returned by the database.
     * @param string $sqlStatement The SQL statement that caused the error (optional).
     * @param string $errFunction The function/method where the error occured (optional).
     * @param string $errFile The filename where the error occured (optional).
     * @param integer $errLine The line number where the error occured (optional).
     * @author Paul Rentschler <par117@psu.edu>
     */
    public static function handleSQLError ($errMsg, $sqlStatement = '', $errFunction = '', $errFile = '', $errLine = '') {
      
      // get a (hopefully) unique id for this error message
      $errorId = self::_generateErrorId();
      
      // build the error message
      $message = self::_buildErrorHeader($errorId);
      if ($errFile <> '' && $errLine <> '') {
        $message .= 'LOCATION: '.$errFile.', line '. $errLine."\n";
      }
      if ($errFunction <> '') {
        $message .= 'FUNCTION: '.$errFunction."\n";
      }
      $message .= "\n";
      $message .= 'TYPE: SQL Error'."\n";
      if ($sqlStatement <> '') {
        $message .= 'SQL STATEMENT: '.$sqlStatement."\n";
      }
      $message .= 'TEXT: '.$errMsg."\n";
      $message .= 'BACKTRACE:'."\n";
      $message .= self::_getBacktrace();
      
      // write the error message to the log
      if (defined('LOG_ERRORS') && LOG_ERRORS) {
        self::_writeToFile(LOG_TYPE_ERROR, $message);
      }
      
      // notify someone about the error
      if (defined('NOTIFY_ON_ERROR') && NOTIFY_ON_ERROR) {
        self::_sendErrorAlert($errorId, $errFile, $errLine);
      }
      
      // display the error message
      if (defined('DEBUGGING') && DEBUGGING) {
        // we are debugging so display the whole error message
        echo '<pre>'.htmlentities($message).'</pre>';
      }
      
    }  // end of function handleSQLError
    
    
    
    /**
     * Write a message to the application log file.
     * 
     * Adds a date/time stamp and the current user to the message
     *   provided and writes it out the application log file specified
     *   by LOG_APPLICATION_FILE.
     * 
     * @param string $message The text of the message to write to the log file.
     * @author Paul Rentschler <par117@psu.edu>
     */
    public static function write ($message) {
      
      // make sure the message is not blank
      $message = trim($message);
      if ($message <> '') {
        // generate a date/time stamp
        $timestamp = '['.date('Y-m-d H:i').'] ';
        
        // get the user
        $user = self::_getCurrentUser();
        
        // build the full log entry
        $logEntry = $timestamp;
        if ($user <> '') {
          $logEntry .= $user.': ';
        }
        $logEntry .= $message;
        
        // write the log entry
        self::_writeToFile(LOG_TYPE_APPLICATION, $logEntry);
      }
      
    }  // end of function write
    
    
    
    /**
     * Create a unique error identification number
     * 
     * @return string An error ID number.
     * @author Paul Rentschler <par117@psu.edu>
     */
    protected static function _generateErrorId () {

      // create a (hopefully) unique id for a error message
      $errorId = date('YmdHis');
      return $errorId;
      
    }  // end of function _generateErrorId
    
    
    
    /**
     * Create the error message header which contains the date/time,
     *   hostname, and logged in user.
     *   
     * @param string $errorId The unique error id value that will get inserted into
     *                         the header and uniquely identify this error message.
     * @return string The message header as a string.
     * @author Paul Rentschler <paul@rentschler.ws>
     */
    protected static function _buildErrorHeader ($errorId) {

      // determine the host
      $host = '';
      if (isset($_SERVER['SERVER_NAME']) && isset($_SERVER['SERVER_ADDR'])) {
        $host = $_SERVER['SERVER_NAME'].' ('.$_SERVER['SERVER_ADDR'].')';
      } elseif (isset($_SERVER['SERVER_NAME'])) {
        $host = $_SERVER['SERVER_NAME'];
      } elseif (isset($_SERVER['SERVER_ADDR'])) {
        $host = $_SERVER['SERVER_ADDR'];
      }
      
      // build the message
      $message = 'ERROR ID: '.$errorId."\n";
      $message .= 'DATE/TIME: '.date('F j, Y, g:i a')."\n"; 
      if (isset($host) && $host <> '') {
        $message .= 'HOST: '.$host."\n";
      }
      $user = self::_getCurrentUser();
      if ($user <> '') {
        $message .= 'USER: '.$user."\n";
      }
      
      return $message;
      
    }  // end of function _buildErrorHeader
    
    
    
    /**
     * Generate a history of functions called prior to the error.
     * 
     * @param integer $initialEntriesToIgnore Number of entries in the history to ignore before building the history.
     * @return string All the functions that were called prior to the error, one per line.
     * @author Paul Rentschler <paul@rentschler.ws>
     */
    protected static function _getBacktrace ($initialEntriesToIgnore = 2) {

      // get the backtrace array
      $traceArray = debug_backtrace();
      
      /*** TODO: refactor this code to work better and actually have some comments! */
      
      // init vars
      $s = '';
      $MAXSTRLEN = 0;
      
      for ($i = 0; $i < $initialEntriesToIgnore; $i++) {
        array_shift($traceArray);
      }
  
      $tabs = sizeof($traceArray) - 1;
      foreach($traceArray as $arr) {
        $tabs -= 1;                                              
        if (isset($arr['class'])) {
          $s .= $arr['class'].".";
        }
  
        $args = array();                                         
        if (!empty($arr['args'])) {
          foreach ($arr['args'] as $v) {                                                        
            if (is_null($v)) {
              $args[] = 'null';
  
            } elseif (is_array($v)) {
              $args[] = 'Array['.sizeof($v).']';
  
            } elseif (is_object($v)) {
              $args[] = 'Object:'.get_class($v);
  
            } elseif (is_bool($v)) {
              $args[] = $v ? 'true' : 'false';
  
            } else {
              $v = (string)@$v;
              if ($MAXSTRLEN == 0) {
                $str = htmlspecialchars($v);
              } else {
                $str = htmlspecialchars(substr($v, 0, $MAXSTRLEN));
                if (strlen($v) > $MAXSTRLEN) {
                  $str .= '...';
                }
              }
              $args[] = "\"" . $str . "\"";
            }
          }
        }
  
        $s .= $arr['function'].'('.implode(', ', $args) . ')';
        $Line = (isset($arr['line']) ? $arr['line']: "unknown");
        $File = (isset($arr['file']) ? $arr['file']: "unknown");
        $s .= sprintf(" # line %4d, file: %s", $Line, $File, $File);
        $s .= "\n\n";
      }
      return $s;
  
    }  // end of function _getBacktrace
    
    
    
    /**
     * Convert the errorlevel number to text.
     * 
     * @param integer $errorLevel The numeric error level of the current error.
     * @param string $separator The character(s) to be used to separate the various error level strings.
     * @return string Textual representation of the error(s) raised.
     * @author Paul Rentschler <paul@rentschler.ws>
     */
    protected static function _convertErrorLevelToString ($errorLevel, $separator = ', ') {
    
      // define textual representations for the error level numbers
      $errorlevels = array( E_ERROR => 'Error',
                            E_RECOVERABLE_ERROR => 'Recoverable Error',
                            E_WARNING => 'Warning',
                            E_PARSE => 'Parse',
                            E_NOTICE => 'Notice',
                            E_STRICT => 'Strict',
                            E_CORE_ERROR => 'Core Error',
                            E_CORE_WARNING => 'Core Warning',
                            E_COMPILE_ERROR => 'Compile Error',
                            E_COMPILE_WARNING => 'Compile Warning',
                            E_USER_ERROR => 'User Error',
                            E_USER_WARNING => 'User Warning',
                            E_USER_NOTICE => 'User Notice' );
                            
      // the depreciated error levels are new to PHP 5.3+
      if (version_compare(phpversion(), '5.3.0') >= 0) {
        $errorlevels[E_DEPRECATED] = 'Deprecated';
        $errorlevels[E_USER_DEPRECATED] = 'User Deprecated';
      }
                                  
      // create an array of text values for the current error level
      $errors = array();
      foreach ($errorlevels as $number => $name) {
        if (($errorLevel & $number) == $number) {
          $errors[] = $name;
        }
      }
      
      // return the textual version of the error level
      $result = '';
      if (isset($errors) && is_array($errors) && count($errors) > 0) {
        $result = implode($separator, $errors);
      }
      return $result;
      
    }  // end of function _convertErrorLevelToString
    
    
    
    /**
     * Determine the current user.
     * 
     * Looks for the current username by checking several
     *   commonly used variables.
     *   
     * @return string Returns the username of the current user or a blank string.
     * @author Paul Rentschler <par117@psu.edu>
     */
    protected static function _getCurrentUser () {

      $username = '';
      
      // check for a web access username
      if (isset($_SERVER['REMOTE_USER'])) {
        $username = trim($_SERVER['REMOTE_USER']);
      }
      
      // check for a user session object
      if (isset($_SESSION['cr_user'])) {
        $username = trim($_SESSION['cr_user']->GetFullName());
      }
      
      /*** TODO: add a method that checks for a username that was passed to the AppController */
      
      return $username;
      
    }  // end of function _getCurrentUser
    
    
    
    /**
     * Write the message to the appropriate log file.
     * 
     * @param string $logType The type of log message that is being written.
     *                        Use the constants that start with LOG_TYPE_.
     * @param string $message The message to be written.
     * @author Paul Rentschler <par117@psu.edu>
     */
    protected static function _writeToFile ($logType, $message) {
      
      // verify that the $logType is valid
      if (self::_isValidLogType($logType)) {
        // determine what file to open
        $filename = '';
        switch ($logType) {
        case LOG_TYPE_APPLICATION:
            if (defined('LOG_APPLICATION_FILE')) {
                $filename = LOG_APPLICATION_FILE;
            }
            break;
            
        case LOG_TYPE_DEBUG:
            if (defined('LOG_DEBUG_FILE')) {
                $filename = LOG_DEBUG_FILE;
            }
            break;
            
        case LOG_TYPE_ERROR:
            if (defined('LOG_ERRORS_FILE')) {
                $filename = LOG_ERRORS_FILE;
            }
            break;
        }
        
        // verify that the directory exists
        if (file_exists(dirname($filename))) {
          // write the message to the file
          file_put_contents($filename, $message."\n", FILE_APPEND);
        }
      }
      
    }  // end of function _writeToFile
    
    
    
    /**
     * Verify that the log type is valid.
     * 
     * @param string $logType The type of log message to validate.
     * @return boolean Whether or not the $logType is valid.
     * @author Paul Rentschler <par117@psu.edu>
     */
    protected static function _isValidLogType ($logType) {
      
      // assume the worst
      $result = false;
      
      // see if there is a message type constant with this valid
      $constants = get_defined_constants(true);
      foreach ($constants['user'] as $constant => $value) {
        if (substr($constant, 0, 9) == 'LOG_TYPE_' && $value == $logType) {
          $result = true;
        }
      }
      
      return $result;
      
    }  // end of function _isValidLogType
    
    
    
    /**
     * Send a e-mail notification when an error occurs.
     * 
     * For security purposes, the error message and any details
     *   about the error are not included in the e-mail.
     * 
     * @param string $errorId The unique error id value that will get inserted into
     *                         the header and uniquely identify this error message.
     * @param string $errFile The filename where the error occured (optional).
     * @param integer $errLine The line number where the error occured (optional).
     * @author Paul Rentschler <par117@psu.edu>
     */
    protected static function _sendErrorAlert ($errorId, $errFile = '', $errLine = 0) {
      
      // compose the message
      $msg = 'An error has occurred in the '.APPLICATION_NAME.' application.'."\n";
      if ($errFile <> '' && $errLine > 0) {
        $msg .= 'The error occurred in '.$errFile.' on line '.$errLine.".\n";
      }
      $msg .= 'Please reference error number ('.$errorId.') in the error log for details.'."\n";

      // set the subject
      $subject = 'Error in '.APPLICATION_NAME;
      
      // verify that we have the to and from addresses
      if ( defined('NOTIFY_ERROR_ADDRESS') && NOTIFY_ERROR_ADDRESS <> '' &&
           defined('NOTIFY_SENDER_ADDRESS') && NOTIFY_SENDER_ADDRESS <> '' ) {
        // build the header
        $headers = 'From: '.NOTIFY_SENDER_ADDRESS."\r\n";
        
        // send the e-mail
        mail(NOTIFY_ERROR_ADDRESS, $subject, $msg, $headers);
      }
      
    }  // end of function _sendErrorAlert
    
  }  // end of class Log
